import{r as w,S as O,T as $,U as b,A as P,V as R,i as g,W as E,I as T,X as C,k as F,D as S,s as A,g as z}from"./entry.85d85229.js";const B=()=>null;function I(...o){const u=typeof o[o.length-1]=="string"?o.pop():void 0;typeof o[0]!="string"&&o.unshift(u);let[a,r,t={}]=o;if(typeof a!="string")throw new TypeError("[nuxt] [asyncData] key must be a string.");if(typeof r!="function")throw new TypeError("[nuxt] [asyncData] handler must be a function.");t.server=t.server??!0,t.default=t.default??B,t.lazy=t.lazy??!1,t.immediate=t.immediate??!0;const e=R(),h=()=>e.isHydrating?e.payload.data[a]:e.static.data[a],c=()=>h()!==void 0;e._asyncData[a]||(e._asyncData[a]={data:w(h()??t.default()),pending:w(!c()),error:O(e.payload._errors,a),status:w("idle")});const s={...e._asyncData[a]};s.refresh=s.execute=(i={})=>{if(e._asyncDataPromises[a]){if(i.dedupe===!1)return e._asyncDataPromises[a];e._asyncDataPromises[a].cancelled=!0}if((i._initial||e.isHydrating&&i._initial!==!1)&&c())return h();s.pending.value=!0,s.status.value="pending";const l=new Promise((n,f)=>{try{n(r(e))}catch(v){f(v)}}).then(n=>{if(l.cancelled)return e._asyncDataPromises[a];let f=n;t.transform&&(f=t.transform(n)),t.pick&&(f=M(f,t.pick)),s.data.value=f,s.error.value=null,s.status.value="success"}).catch(n=>{if(l.cancelled)return e._asyncDataPromises[a];s.error.value=n,s.data.value=g(t.default()),s.status.value="error"}).finally(()=>{l.cancelled||(s.pending.value=!1,e.payload.data[a]=s.data.value,s.error.value&&(e.payload._errors[a]=E(s.error.value)),delete e._asyncDataPromises[a])});return e._asyncDataPromises[a]=l,e._asyncDataPromises[a]};const p=()=>s.refresh({_initial:!0}),_=t.server!==!1&&e.payload.serverRendered;{const i=T();if(i&&!i._nuxtOnBeforeMountCbs){i._nuxtOnBeforeMountCbs=[];const n=i._nuxtOnBeforeMountCbs;i&&($(()=>{n.forEach(f=>{f()}),n.splice(0,n.length)}),b(()=>n.splice(0,n.length)))}_&&e.isHydrating&&c()?(s.pending.value=!1,s.status.value=s.error.value?"error":"success"):i&&(e.payload.serverRendered&&e.isHydrating||t.lazy)&&t.immediate?i._nuxtOnBeforeMountCbs.push(p):t.immediate&&p(),t.watch&&P(t.watch,()=>s.refresh());const l=e.hook("app:data:refresh",n=>{if(!n||n.includes(a))return s.refresh()});i&&b(l)}const m=Promise.resolve(e._asyncDataPromises[a]).then(()=>s);return Object.assign(m,s),m}function M(o,u){const a={};for(const r of u)a[r]=o[r];return a}function U(o,u,a){const[r={},t]=typeof u=="string"?[{},u]:[u,a],e=r.key||C([t,g(r.baseURL),typeof o=="string"?o:"",g(r.params||r.query)]);if(!e||typeof e!="string")throw new TypeError("[nuxt] [useFetch] key must be a string: "+e);if(!o)throw new Error("[nuxt] [useFetch] request is missing.");const h=e===t?"$f"+e:e,c=F(()=>{let y=o;return typeof y=="function"&&(y=y()),g(y)});if(!r.baseURL&&typeof c.value=="string"&&c.value.startsWith("//"))throw new Error('[nuxt] [useFetch] the request URL must not start with "//".');const{server:s,lazy:p,default:_,transform:m,pick:i,watch:l,immediate:n,...f}=r,v=S({...f,cache:typeof r.cache=="boolean"?void 0:r.cache}),k={server:s,lazy:p,default:_,transform:m,pick:i,immediate:n,watch:l===!1?[]:[v,c,...l||[]]};let d;return I(h,()=>{var D;return(D=d==null?void 0:d.abort)==null||D.call(d),d=typeof AbortController<"u"?new AbortController:{},typeof c.value=="string"&&c.value.startsWith("/"),(r.$fetch||globalThis.$fetch)(c.value,{signal:d.signal,...v})},k)}const x=A("error",{state:()=>({errors:{},message:"",status:0,statusText:"",timeout:1e4})});function K(o,u={}){let a={};const r=z("XSRF-TOKEN");return r.value&&(a["X-XSRF-TOKEN"]=r.value),window.localStorage.getItem("token")&&(a.Autherization=window.localStorage.getItem("token")),U("http://localhost:8000"+o,{credentials:"include",watch:!1,...u,headers:{...a,...u==null?void 0:u.headers},onRequest(){x().$reset()},onResponse({response:t}){},onResponseError({response:t}){const e=x();e.$state.errors=t._data.errors,e.$state.message=t._data.message,e.$state.status=t.status,e.$state.statusText=t.statusText,setTimeout(()=>{e.$reset()},e.$state.timeout)}},"$Ov7SIxRbXh")}export{x as a,K as u};
